URL: https://docs.gtk.org/gobject/concepts.html
Title: Type System Concepts<a href="#type-system-concepts" class="md-anchor" title="Permanent link"></a>
Content:
API Version: 2.0
Library Version: 2.81.0
Generated by <a href="https://gitlab.gnome.org/GNOME/gi-docgen">gi-docgen</a> 2023.1
Most modern programming languages come with their own native object systems
and additional fundamental algorithmic language constructs. Just as GLib
serves as an implementation of such fundamental types and algorithms (linked
lists, hash tables and so forth), the GLib Object System provides the
required implementations of a flexible, extensible, and intentionally easy
to map (into other languages) object-oriented framework for C. The
substantial elements that are provided can be summarized&nbsp;as:
GObject, and its lower-level type system, GType, are used by <span class="caps">GTK</span> and most
<span class="caps">GNOME</span> libraries to&nbsp;provide:
A lot of programmers are used to working with compiled-only or dynamically
interpreted-only languages and do not understand the challenges associated
with cross-language interoperability. This introduction tries to provide an
insight into these challenges and briefly describes the solution chosen by&nbsp;GLib.
The following chapters go into greater detail into how GType and GObject
work and how you can use them as a C programmer. It is useful to keep in
mind that allowing access to C objects from other interpreted languages was
one of the major design goals: this can often explain the sometimes rather
convoluted APIs and features present in this&nbsp;library.
One could say that a programming language is merely a way to create data
types and manipulate them. Most languages provide a number of
language-native types and a few primitives to create more complex types
based on these primitive&nbsp;types.
In C, the language provides types such as char, long, pointer. During
compilation of C code, the compiler maps these language types to the
compiler’s target architecture machine types. If you are using a C
interpreter (assuming one exists), the interpreter (the program which
interprets the source code and executes it) maps the language types to the
machine types of the target machine at runtime, during the program execution
(or just before execution if it uses a Just In Time compiler&nbsp;engine).
Perl and Python are interpreted languages which do not really provide type
definitions similar to those used by C. Perl and Python programmers
manipulate variables and the type of the variables is decided only upon the
first assignment or upon the first use which forces a type on the variable.
The interpreter also often provides a lot of automatic conversions from one
type to the other. For example, in Perl, a variable which holds an integer
can be automatically converted to a string given the required&nbsp;context:
Of course, it is also often possible to explicitly specify conversions when
the default conversions provided by the language are not&nbsp;intuitive.
C APIs are defined by a set of functions and global variables which are
usually exported from a binary. C functions have an arbitrary number of
arguments and one return value. Each function is thus uniquely identified by
the function name and the set of C types which describe the function
arguments and return value. The global variables exported by the <span class="caps">API</span> are
similarly identified by their name and their&nbsp;type.
A C <span class="caps">API</span> is thus merely defined by a set of names to which a set of types are
associated. If you know the function calling convention and the mapping of
the C types to the machine types used by the platform you are on, you can
resolve the name of each function to find where the code associated to this
function is located in memory, and then construct a valid argument list for
the function. Finally, all you have to do is trigger a call to the target C
function with the argument&nbsp;list.
For the sake of discussion, here is a sample C function and the associated
32 bit x86 assembly code generated by <span class="caps">GCC</span> on a Linux&nbsp;computer:
The assembly code shown above is pretty straightforward: the first
instruction pushes the hexadecimal value 0xa (decimal value 10) as a 32-bit
integer on the stack and calls <code>function_foo</code>. As you can see, C function
calls are implemented by <span class="caps">GCC</span> as native function calls (this is probably the
fastest implementation&nbsp;possible).
Now, let’s say we want to call the C function <code>function_foo</code> from a Python
program. To do this, the Python interpreter needs&nbsp;to:
The process described above is pretty complex and there are a lot of ways to
make it entirely automatic and transparent to C and Python&nbsp;programmers:
The solution used by GLib is to use the GType library which holds at runtime
a description of all the objects manipulated by the programmer. This
so-called dynamic type library is then used by special generic glue code to
automatically convert function parameters and function calling conventions
between different runtime&nbsp;domains.
The greatest advantage of the solution implemented by GType is that the glue
code sitting at the runtime domain boundaries is written once: the figure
below states this more&nbsp;clearly.
<img alt="" src="./glue.png">
Currently, there exist multiple generic glue code which makes it possible to
use C objects written with GType directly in a variety of languages, with a
minimum amount of work: there is no need to generate huge amounts of glue
code either automatically or by&nbsp;hand.
Although that goal was arguably laudable, its pursuit has had a major
influence on the whole GType/GObject library. C programmers are likely to be
puzzled at the complexity of the features exposed in the following chapters
if they forget that the GType/GObject library was not only designed to offer
<span class="caps">OO</span>-like features to C programmers but also transparent cross-language&nbsp;interoperability.
A type, as manipulated by the GLib type system, is much more generic than what is usually understood as an Object type. It is best explained by looking at the structure and the functions used to register new types in the type&nbsp;system.
<code>g_type_register_static()</code>, <code>g_type_register_dynamic()</code> and
<code>g_type_register_fundamental()</code> are the C functions, defined in <code>gtype.h</code>
and implemented in <code>gtype.c</code> which you should use to register a new GType in
the program’s type system. It is not likely you will ever need to use
<code>g_type_register_fundamental()</code> but in case you want to, the last chapter
explains how to create new fundamental&nbsp;types.
Fundamental types are top-level types which do not derive from any other
type while other non-fundamental types derive from other types. Upon
initialization, the type system not only initializes its internal data
structures but it also registers a number of core types: some of these are
fundamental types. Others are types derived from these fundamental&nbsp;types.
Fundamental and non-fundamental types are defined&nbsp;by:
Fundamental types are also defined by a set of <code>GTypeFundamentalFlags</code> which
are stored in a <code>GTypeFundamentalInfo</code>. Non-fundamental types are
furthermore defined by the type of their parent which is passed as the
<code>parent_type</code> parameter to <code>g_type_register_static()</code> and
<code>g_type_register_dynamic()</code>.
The major common point between all GLib types (fundamental and
non-fundamental, classed and non-classed, instantiatable and
non-instantiatable) is that they can all be manipulated through a single <span class="caps">API</span>
to copy/assign&nbsp;them.
The <code>GValue</code> structure is used as an abstract container for all of these
types. Its simplistic <span class="caps">API</span> (defined in <code>gobject/gvalue.h</code>) can be used to
invoke the <code>value_table</code> functions registered during type registration: for
example <code>g_value_copy()</code> copies the content of a <code>GValue</code> to another
<code>GValue</code>. This is similar to a C++ assignment which invokes the C++ copy
operator to modify the default bit-by-bit copy semantics of C++/C&nbsp;structures/classes.
The following code shows how you can copy around a 64 bit integer, as well
as a <code>GObject</code> instance&nbsp;pointer:
The important point about the above code is that the exact semantics of the
copy calls is undefined since they depend on the implementation of the copy
function. Certain copy functions might decide to allocate a new chunk of
memory and then to copy the data from the source to the destination. Others
might want to simply increment the reference count of the instance and copy
the reference to the new <code>GValue</code>.
The value table used to specify these assignment functions is documented in
<code>GTypeValueTable</code>.
Interestingly, it is also very unlikely you will ever need to specify a
<code>value_table</code> during type registration because these <code>value_tables</code> are
inherited from the parent types for non-fundamental&nbsp;types.
There are a number of conventions users are expected to follow when creating
new types which are to be exported in a header&nbsp;file:
The implementation of these macros is pretty straightforward: a number of
simple-to-use macros are provided in <code>gtype.h</code>. For the example we used above,
we would write the following trivial code to declare the&nbsp;macros:
Unless your code has special requirements, you can use the <code>G_DEFINE_TYPE</code>
macro to define a&nbsp;class:
Otherwise, the <code>viewer_file_get_type</code> function must be implemented&nbsp;manually:
A lot of types are not instantiatable by the type system and do not have a class. Most of these types are fundamental trivial types such as <code>gchar</code>, and are already registered by&nbsp;GLib.
In the rare case of needing to register such a type in the type system, fill a <code>GTypeInfo</code> structure with zeros since these types are also most of the time&nbsp;fundamental:
Having non-instantiatable types might seem a bit useless: what good is a
type if you cannot instantiate an instance of that type? Most of these types
are used in conjunction with <code>GValue</code>s: a <code>GValue</code> is initialized with an
integer or a string and it is passed around by using the registered type’s
<code>value_table</code>. <code>GValue</code>s (and by extension these trivial fundamental types)
are most useful when used in conjunction with object properties and&nbsp;signals.
Types which are registered with a class and are declared instantiatable are
what most closely resembles an object. Although <code>GObject</code>s are the most well
known type of instantiatable classed types, other kinds of similar objects
used as the base of an inheritance hierarchy have been externally developed
and they are all built on the fundamental features described&nbsp;below.
For example, the code below shows how you could register such a fundamental
object type in the type system (using none of the GObject convenience <span class="caps">API</span>):
Upon the first call to <code>viewer_file_get_type</code>, the type named <code>ViewerFile</code> will be registered in the type system as inheriting from the type <code>G_TYPE_OBJECT</code>.
Every object must define two structures: its class structure and its instance structure. All class structures must contain as first member a <code>GTypeClass</code> structure. All instance structures must contain as first member a <code>GTypeInstance</code> structure. The declaration of these C types, coming from <code>gtype.h</code> is shown&nbsp;below:
These constraints allow the type system to make sure that every object instance (identified by a pointer to the object’s instance structure) contains in its first bytes a pointer to the object’s class&nbsp;structure.
This relationship is best explained by an example: let’s take object B which inherits from object&nbsp;A:
The C standard mandates that the first field of a C structure is stored starting in the first byte of the buffer used to hold the structure’s fields in memory. This means that the first field of an instance of an object B is A’s first field which in turn is <code>GTypeInstance</code><span class="quo">‘</span>s first field which in turn is <code>g_class</code>, a pointer to B’s class&nbsp;structure.
Thanks to these simple conditions, it is possible to detect the type of every object instance by&nbsp;doing:
or, more&nbsp;compactly:
Instantiation of these types can be done with <code>g_type_create_instance()</code>, which
will look up the type information structure associated with the type
requested. Then, the instance size and instantiation policy (if the
<code>n_preallocs</code> field is set to a non-zero value, the type system allocates the
object’s instance structures in chunks rather than mallocing for every
instance) declared by the user are used to get a buffer to hold the object’s
instance&nbsp;structure.
If this is the first instance of the object ever created, the type system
must create a class structure. It allocates a buffer to hold the object’s
class structure and initializes it. The first part of the class structure
(ie: the embedded parent class structure) is initialized by copying the
contents from the class structure of the parent class. The rest of class
structure is initialized to zero. If there is no parent, the entire class
structure is initialized to zero. The type system then invokes the
<code>base_init</code> functions <code>(GBaseInitFunc)</code> from topmost fundamental
object to bottom-most most derived object. The object’s <code>class_init</code>
<code>(GClassInitFunc)</code> function is invoked afterwards to complete initialization
of the class structure. Finally, the object’s interfaces are initialized (we
will discuss interface initialization in more detail&nbsp;later).
Once the type system has a pointer to an initialized class structure, it
sets the object’s instance class pointer to the object’s class structure and
invokes the object’s <code>instance_init</code> <code>(GInstanceInitFunc)</code> functions, from
top-most fundamental type to bottom-most most-derived&nbsp;type.
Object instance destruction through <code>g_type_free_instance()</code> is very simple:
the instance structure is returned to the instance pool if there is one and
if this was the last living instance of the object, the class is&nbsp;destroyed.
Class destruction (the concept of destruction is sometimes partly referred
to as finalization in GType) is the symmetric process of the initialization:
interfaces are destroyed first. Then, the most derived <code>class_finalize</code>
<code>(GClassFinalizeFunc)</code> function is invoked. Finally, the <code>base_finalize</code>
<code>(GBaseFinalizeFunc)</code> functions are invoked from bottom-most most-derived type
to top-most fundamental type and the class structure is&nbsp;freed.
The base initialization/finalization process is very similar to the C++
constructor/destructor paradigm. The practical details are different though
and it is important not to get confused by superficial similarities. GTypes
have no instance destruction mechanism. It is the user’s responsibility to
implement correct destruction semantics on top of the existing GType code.
(This is what <code>GObject</code> does) Furthermore, C++
code equivalent to the <code>base_init</code> and <code>class_init</code> callbacks of GType is
usually not needed because C++ cannot really create object types at&nbsp;runtime.
The instantiation/finalization process can be summarized as&nbsp;follows:
GType’s interfaces are very similar to Java’s interfaces. They allow to
describe a common <span class="caps">API</span> that several classes will adhere to. Imagine the play,
pause and stop buttons on hi-fi equipment—those can be seen as a playback
interface. Once you know what they do, you can control your <span class="caps">CD</span> player, <span class="caps">MP3</span>
player or anything that uses these&nbsp;symbols.
To declare an interface you have to register a non-instantiatable classed
type which derives from <code>GTypeInterface</code>. The following piece of code declares
such an&nbsp;interface:
The interface function, <code>viewer_editable_save</code> is implemented in a pretty
simple&nbsp;way:
<code>viewer_editable_get_type</code> registers a type named <code>ViewerEditable</code> which
inherits from <code>G_TYPE_INTERFACE</code>. All interfaces must be children of
<code>G_TYPE_INTERFACE</code> in the inheritance&nbsp;tree.
An interface is defined by only one structure which must contain as first
member a <code>GTypeInterface</code> structure. The interface structure is expected to
contain the function pointers of the interface methods. It is good style to
define helper functions for each of the interface methods which simply call
the interface’s method directly: <code>viewer_editable_save</code> is one of&nbsp;these.
If you have no special requirements you can use the <code>G_IMPLEMENT_INTERFACE</code>
macro to implement an&nbsp;interface:
If your code does have special requirements, you must write a custom
<code>get_type</code> function to register your GType which inherits from some GObject
and which implements the interface <code>ViewerEditable</code>. For example, this code
registers a new <code>ViewerFile</code> class which implements <code>ViewerEditable</code>:
<code>g_type_add_interface_static()</code> records in the type system that the given
<code>ViewerFile</code> type implements also <code>ViewerEditable</code>
(<code>viewer_editable_get_type()</code> returns the type of <code>ViewerEditable</code>). The
<code>GInterfaceInfo</code> structure holds information about the implementation of the&nbsp;interface:
When an instantiatable classed type which implements an interface (either
directly or by inheriting an implementation from a superclass) is created
for the first time, its class structure is initialized following the process
described in the section called “Instantiatable classed types: objects”.
After that, the interface implementations associated with the type are&nbsp;initialized.
First a memory buffer is allocated to hold the interface structure. The
parent’s interface structure is then copied over to the new interface
structure (the parent interface is already initialized at that point). If
there is no parent interface, the interface structure is initialized with
zeros. The <code>g_type</code> and the <code>g_instance_type</code> fields are then initialized:
<code>g_type</code> is set to the type of the most-derived interface and <code>g_instance_type</code>
is set to the type of the most derived type which implements this&nbsp;interface.
The interface’s <code>base_init</code> function is called, and then the interface’s
<code>default_init</code> is invoked. Finally if the type has registered an
implementation of the interface, the implementation’s <code>interface_init</code>
function is invoked. If there are multiple implementations of an interface
the <code>base_init</code> and <code>interface_init</code> functions will be invoked once for each
implementation&nbsp;initialized.
It is thus recommended to use a <code>default_init</code> function to initialize an
interface. This function is called only once for the interface no matter how
many implementations there are. The <code>default_init</code> function is declared by
<code>G_DEFINE_INTERFACE</code> which can be used to define the&nbsp;interface:
Or you can do that yourself in a GType function for your&nbsp;interface:
In summary, interface initialization uses the following&nbsp;functions:
When the last instance of an instantiatable type which registered an
interface implementation is destroyed, the interface’s implementations
associated to the type are&nbsp;destroyed.
To destroy an interface implementation, GType first calls the
implementation’s <code>interface_finalize</code> function and then the interface’s
most-derived <code>base_finalize</code> function.
Again, it is important to understand, as in the section called “Interface
Initialization”, that both <code>interface_finalize</code> and <code>base_finalize</code> are
invoked exactly once for the destruction of each implementation of an
interface. Thus, if you were to use one of these functions, you would need
to use a static integer variable which would hold the number of instances of
implementations of an interface such that the interface’s class is destroyed
only once (when the integer variable reaches&nbsp;zero).
The above process can be summarized as&nbsp;follows: 
The previous chapter discussed the details of GLib’s Dynamic Type System.
The GObject library also contains an implementation for a base fundamental
type named <code>GObject</code>.
<code>GObject</code> is a fundamental classed instantiatable type. It&nbsp;implements:
All the <span class="caps">GNOME</span> libraries which use the GLib type system (like <span class="caps">GTK</span> and
GStreamer) inherit from <code>GObject</code> which is why it is important to understand
the details of how it&nbsp;works.
The <code>g_object_new()</code> family of functions can be used to instantiate any
GType which inherits from the GObject base type. All these functions make
sure the class and instance structures have been correctly initialized by
GLib’s type system and then invoke at one point or another the constructor
class method which is used&nbsp;to:
GObject explicitly guarantees that all class and instance members (except
the fields pointing to the parents) to be set to&nbsp;zero.
Once all construction operations have been completed and constructor
properties set, the constructed class method is&nbsp;called.
Objects which inherit from <code>GObject</code> are allowed to override this
constructed class method. The example below shows how <code>ViewerFile</code> overrides
the parent’s construction&nbsp;process:
If the user instantiates an object <code>ViewerFile</code> with:
If this is the first instantiation of such an object, the
<code>viewer_file_class_init</code> function will be invoked after any
<code>viewer_file_base_class_init</code> function. This will make sure the class
structure of this new object is correctly initialized. Here,
<code>viewer_file_class_init</code> is expected to override the object’s class methods
and setup the class’ own methods. In the example above, the constructed
method is the only overridden method: it is set to
<code>viewer_file_constructed</code>.
Once <code>g_object_new()</code> has obtained a reference to an initialized class
structure, it invokes its constructor method to create an instance of the
new object, if the constructor has been overridden in
<code>viewer_file_class_init</code>. Overridden constructors must chain up to their
parent’s constructor. In order to find the parent class and chain up to the
parent class constructor, we can use the <code>viewer_file_parent_class</code> pointer
that has been set up for us by the <code>G_DEFINE_TYPE</code> macro.
Finally, at one point or another, <code>g_object_constructor</code> is invoked by the
last constructor in the chain. This function allocates the object’s instance
buffer through <code>g_type_create_instance()</code> which means that the
<code>instance_init</code> function is invoked at this point if one was registered.
After <code>instance_init</code> returns, the object is fully initialized and should be
ready to have its methods called by the user. When
<code>g_type_create_instance()</code> returns, <code>g_object_constructor</code> sets the
construction properties (i.e. the properties which were given to
<code>g_object_new()</code>) and returns to the user’s&nbsp;constructor.
The process described above might seem a bit complicated, but it can be
summarized easily by the table below which lists the functions invoked by
<code>g_object_new()</code> and their order of&nbsp;invocation:
Readers should feel concerned about one little twist in the order in which
functions are invoked: while, technically, the class’ constructor method is
called before the GType’s <code>instance_init</code> function (since
<code>g_type_create_instance()</code> which calls <code>instance_init</code> is called by
<code>g_object_constructor</code> which is the top-level class constructor method and
to which users are expected to chain to), the user’s code which runs in a
user-provided constructor will always run after GType’s <code>instance_init</code>
function since the user-provided constructor must (you’ve been warned) chain
up before doing anything&nbsp;useful.
The memory-management <span class="caps">API</span> for GObjects is a bit complicated but the idea
behind it is pretty simple: the goal is to provide a flexible model based on
reference counting which can be integrated in applications which use or
require different memory management models (such as garbage collection). The
methods which are used to manipulate this reference count are described&nbsp;below.
The functions <code>g_object_ref()</code> and <code>g_object_unref()</code> increase and decrease
the reference count, respectively. These functions are thread-safe.
<code>g_clear_object()</code> is a convenience wrapper around <code>g_object_unref()</code> which
also clears the pointer passed to&nbsp;it.
The reference count is initialized to one by <code>g_object_new()</code> which means
that the caller is currently the sole owner of the newly-created reference.
(If the object is derived from <code>GInitiallyUnowned</code>, this reference is
“floating”, and must be “sunk”, i.e. transformed into a real reference.)
When the reference count reaches zero, that is, when <code>g_object_unref()</code> is
called by the last owner of a reference to the object, the <code>dispose()</code> and
the <code>finalize()</code> class methods are&nbsp;invoked.
Finally, after <code>finalize()</code> is invoked, <code>g_type_free_instance()</code> is called
to free the object instance. Depending on the memory allocation policy
decided when the type was registered (through one of the <code>g_type_register_*</code>
functions), the object’s instance memory will be freed or returned to the
object pool for this type. Once the object has been freed, if it was the
last instance of the type, the type’s class will be destroyed as described
in the section called “Instantiatable classed types: objects” and the
section called “Non-instantiatable classed types:&nbsp;interfaces”.
The table below summarizes the destruction process of a <code>GObject</code>:
Weak references are used to monitor object finalization:
<code>g_object_weak_ref()</code> adds a monitoring callback which does not hold a
reference to the object but which is invoked when the object runs its
dispose method. Weak references on the object are automatically dropped when
the instance is disposed, so there is no need to invoke <code>g_object_weak_unref()</code>
from the <code>GWeakNotify</code> callback. Remember that the object instance is not
passed to the <code>GWeakNotify</code> callback because the object has already been
disposed. Instead, the callback receives a pointer to where the object
previously&nbsp;was.
Weak references are also used to implement <code>g_object_add_weak_pointer()</code> and
<code>g_object_remove_weak_pointer()</code>. These functions add a weak reference to
the object they are applied to which makes sure to nullify the pointer given
by the user when object is&nbsp;finalized.
Similarly, <code>GWeakRef</code> can be used to implement weak references if thread
safety is&nbsp;required.
GObject’s memory management model was designed to be easily integrated in
existing code using garbage collection. This is why the destruction process
is split in two phases: the first phase, executed in the <code>dispose()</code> handler is
supposed to release all references to other member objects. The second
phase, executed by the <code>finalize()</code> handler is supposed to complete the object’s
destruction process. Object methods should be able to run without program
error in-between the two&nbsp;phases.
This two-step destruction process is very useful to break reference counting
cycles. While the detection of the cycles is up to the external code, once
the cycles have been detected, the external code can invoke
<code>g_object_run_dispose()</code> which will indeed break any existing cycles since
it will run the dispose handler associated to the object and thus release
all references to other&nbsp;objects.
This explains one of the rules about the <code>dispose()</code> handler stated earlier:
the <code>dispose()</code> handler can be invoked multiple times. Let’s say we have a
reference count cycle: object A references B which itself references object
A. Let’s say we have detected the cycle and we want to destroy the two
objects. One way to do this would be to invoke <code>g_object_run_dispose()</code> on one
of the&nbsp;objects.
If object A releases all its references to all objects, this means it
releases its reference to object B. If object B was not owned by anyone
else, this is its last reference count which means this last unref runs B’s
dispose handler which, in turn, releases B’s reference on object A. If this
is A’s last reference count, this last unref runs A’s dispose handler which
is running for the second time before A’s finalize handler is&nbsp;invoked!
The above example, which might seem a bit contrived, can really happen if
GObjects are being handled by language bindings—hence the rules for object
destruction should be closely&nbsp;followed.
One of GObject’s nice features is its generic get/set mechanism for object
properties. When an object is instantiated, the object’s <code>class_init</code>
handler should be used to register the object’s properties with
<code>g_object_class_install_properties()</code>.
The best way to understand how object properties work is by looking at a
real example of how it is&nbsp;used:
The client code above looks simple but a lot of things happen under the&nbsp;hood:
<code>g_object_set_property()</code> first ensures a property with this name was
registered in file’s <code>class_init</code> handler. If so it walks the class
hierarchy, from bottom-most most-derived type, to top-most fundamental type
to find the class which registered that property. It then tries to convert
the user-provided GValue into a GValue whose type is that of the associated&nbsp;property.
If the user provides a signed char GValue, as is shown here, and if the
object’s property was registered as an <code>unsigned int</code>, <code>g_value_transform()</code>
will try to transform the input signed char into an unsigned int. Of course,
the success of the transformation depends on the availability of the
required transform function. In practice, there will almost always be a
transformation which matches and conversion will be carried out if&nbsp;needed.
After transformation, the GValue is validated by <code>g_param_value_validate()</code>
which makes sure the user’s data stored in the GValue matches the
characteristics specified by the property’s GParamSpec. Here, the GParamSpec
we provided in <code>class_init</code> has a validation function which makes sure that
the GValue contains a value which respects the minimum and maximum bounds of
the GParamSpec. In the example above, the client’s GValue does not respect
these constraints (it is set to 11, while the maximum is 10). As such, the
<code>g_object_set_property()</code> function will return with an&nbsp;error.
If the user’s GValue had been set to a valid value,
<code>g_object_set_property()</code> would have proceeded with calling the object’s
<code>set_property</code> class method. Here, since our implementation of ViewerFile
did override this method, execution would jump to <code>viewer_file_set_property</code>
after having retrieved from the GParamSpec the <code>param_id</code> which had been
stored by <code>g_object_class_install_property()</code>.
Once the property has been set by the object’s <code>set_property</code> class method,
execution returns to <code>g_object_set_property()</code> which makes sure that the
“notify” signal is emitted on the object’s instance with the changed
property as parameter unless notifications were frozen by
<code>g_object_freeze_notify()</code>.
<code>g_object_thaw_notify()</code> can be used to re-enable notification of property
modifications through the “notify” signal. It is important to remember that
even if properties are changed while property change notification is frozen,
the “notify” signal will be emitted once for each of these changed
properties as soon as the property change notification is thawed: no
property change is lost for the “notify” signal, although multiple
notifications for a single property are compressed. Signals can only be
delayed by the notification freezing&nbsp;mechanism.
It sounds like a tedious task to set up GValues every time when one wants to
modify a property. In practice one will rarely do this. The functions
<code>g_object_set_property()</code> and <code>g_object_get_property()</code> are meant to be used
by language bindings. For application there is an easier way and that is
described&nbsp;next.
It is interesting to note that the <code>g_object_set()</code> and
<code>g_object_set_valist()</code> (variadic version) functions can be used to set
multiple properties at once. The client code shown above can then be
re-written&nbsp;as:
This saves us from managing the GValues that we were needing to handle when
using <code>g_object_set_property()</code>. The code above will trigger one notify
signal emission for each property&nbsp;modified.
Equivalent <code>_get</code> versions are also available: <code>g_object_get()</code> and
<code>g_object_get_valist()</code> (variadic version) can be used to get numerous
properties at&nbsp;once.
These high level functions have one drawback — they don’t provide a return
value. One should pay attention to the argument types and ranges when using
them. A known source of errors is to pass a different type from what the
property expects; for instance, passing an integer when the property expects
a floating point value and thus shifting all subsequent parameters by some
number of bytes. Also forgetting the terminating <span class="caps">NULL</span> will lead to undefined&nbsp;behaviour.
This explains how <code>g_object_new()</code>, <code>g_object_newv()</code> and
<code>g_object_new_valist()</code> work: they parse the user-provided variable number
of parameters and invoke <code>g_object_set()</code> on the parameters only after the
object has been successfully constructed. The “notify” signal will be
emitted for each property&nbsp;set.
Closures are central to the concept of asynchronous signal delivery which is
widely used throughout <span class="caps">GTK</span> and <span class="caps">GNOME</span> applications. A closure is an
abstraction, a generic representation of a callback. It is a small structure
which contains three&nbsp;objects:
The <code>GClosure</code> structure represents the common functionality of all closure
implementations: there exists a different closure implementation for each
separate runtime which wants to use the GObject type system. The GObject
library provides a simple GCClosure type which is a specific implementation
of closures to be used with C/C++&nbsp;callbacks.
A <code>GClosure</code> provides simple&nbsp;services:
If you are using C or C++ to connect a callback to a given event, you will
either use simple <code>GCClosures</code> which have a pretty minimal <span class="caps">API</span> or the even
simpler <code>g_signal_connect()</code> functions (which will be presented a bit&nbsp;later).
<code>g_cclosure_new()</code> will create a new closure which can invoke the
user-provided <code>callback_func</code> with the user-provided <code>user_data</code> as its last
parameter. When the closure is finalized (second stage of the destruction
process), it will invoke the <code>destroy_data</code> function if the user has
supplied&nbsp;one.
<code>g_cclosure_new_swap()</code> will create a new closure which can invoke the
user-provided <code>callback_func</code> with the user-provided <code>user_data</code> as its
first parameter (instead of being the last parameter as with
<code>g_cclosure_new()</code>). When the closure is finalized (second stage of the
destruction process), it will invoke the <code>destroy_data</code> function if the user
has supplied&nbsp;one.
As was explained above, closures hide the details of callback invocation. In
C, callback invocation is just like function invocation: it is a matter of
creating the correct stack frame for the called function and executing a
call assembly&nbsp;instruction.
C closure marshallers transform the array of GValues which represent the
parameters to the target function into a C-style function parameter list,
invoke the user-supplied C function with this new parameter list, get the
return value of the function, transform it into a GValue and return this
GValue to the marshaller&nbsp;caller.
A generic C closure marshaller is available as
<code>g_cclosure_marshal_generic()</code> which implements marshalling for all function
types using libffi. Custom marshallers for different types are not needed
apart from performance critical code where the libffi-based marshaller may
be too&nbsp;slow.
An example of a custom marshaller is given below, illustrating how GValues
can be converted to a C function call. The marshaller is for a C function
which takes an integer as its first parameter and returns <code>void</code>.
There exist other kinds of marshallers, for example there is a generic
Python marshaller which is used by all Python closures (a Python closure is
used to invoke a callback written in Python). This Python marshaller
transforms the input GValue list representing the function parameters into a
Python tuple which is the equivalent structure in&nbsp;Python.
GObject’s signals have nothing to do with standard <span class="caps">UNIX</span> signals: they
connect arbitrary application-specific events with any number of listeners.
For example, in <span class="caps">GTK</span>, every user event (keystroke or mouse move) is received
from the windowing system and generates a <span class="caps">GTK</span> event in the form of a signal
emission on the widget object&nbsp;instance.
Each signal is registered in the type system together with the type on which
it can be emitted: users of the type are said to connect to the signal on a
given type instance when they register a closure to be invoked upon the
signal emission. Users can also emit the signal by themselves or stop the
emission of the signal from within one of the closures connected to the&nbsp;signal.
When a signal is emitted on a given type instance, all the closures
connected to this signal on this type instance will be invoked. All the
closures connected to such a signal represent callbacks whose signature
looks&nbsp;like:
To register a new signal on an existing type, we can use any of
<code>g_signal_newv()</code>, <code>g_signal_new_valist()</code> or <code>g_signal_new()</code> functions:
The number of parameters to these functions is a bit intimidating but they are relatively&nbsp;simple:
As you can see from the above definition, a signal is basically a
description of the closures which can be connected to this signal and a
description of the order in which the closures connected to this signal will
be&nbsp;invoked.
If you want to connect to a signal with a closure, you have three&nbsp;possibilities:
It is also possible to connect a different kind of callback on a given
signal: emission hooks are invoked whenever a given signal is emitted
whatever the instance on which it is emitted. Emission hooks are connected
with <code>g_signal_add_emission_hook()</code> and removed with
<code>g_signal_remove_emission_hook()</code>.
Signal emission is done through the use of the <code>g_signal_emit()</code> family of&nbsp;functions.
Signal emission can be decomposed in 6&nbsp;steps:
If, at any point during the emission (except in the <code>RUN_CLEANUP</code> or
<code>EMISSION_HOOK</code> states), one of the closures stops the signal emission with
<code>g_signal_stop_emission()</code>, the emission jumps to the <code>RUN_CLEANUP</code> state.
If, at any point during emission, one of the closures or emission hook emits
the same signal on the same instance, emission is restarted from the
<code>RUN_FIRST</code> state.
The accumulator function is invoked in all states, after invocation of each
closure (except in <code>RUN_EMISSION_HOOK</code> and <code>RUN_CLEANUP</code>). It accumulates
the closure return value into the signal return value and returns <code>TRUE</code> or
<code>FALSE</code>.  If, at any point, it does not return <code>TRUE</code>, emission jumps to
<code>RUN_CLEANUP</code> state.
If no accumulator function was provided, the value returned by the last
handler run will be returned by <code>g_signal_emit()</code>.
All the functions related to signal emission or signal connection have a
parameter named the detail. Sometimes, this parameter is hidden by the <span class="caps">API</span>
but it is always there, in one form or&nbsp;another.
Of the three main connection functions, only one has an explicit detail
parameter as a GQuark: <code>g_signal_connect_closure_by_id()</code>.
The two other functions, <code>g_signal_connect_closure()</code> and
<code>g_signal_connect_data()</code> hide the detail parameter in the signal name
identification. Their <code>detailed_signal</code> parameter is a string which
identifies the name of the signal to connect to. The format of this string
should match <code>signal_name::detail_name</code>. For example, connecting to the
signal named <code>notify::cursor_position</code> will actually connect to the signal
named <code>notify</code> with the <code>cursor_position</code> detail. Internally, the detail
string is transformed to a GQuark if it is&nbsp;present.
Of the four main signal emission functions, one hides it in its signal name
parameter: <code>g_signal_emit_by_name()</code>. The other three have an explicit
detail parameter as a GQuark again: <code>g_signal_emit()</code>, <code>g_signal_emitv()</code>
and <code>g_signal_emit_valist()</code>.
If a detail is provided by the user to the emission function, it is used
during emission to match against the closures which also provide a detail.
If a closure’s detail does not match the detail provided by the user, it
will not be invoked (even though it is connected to a signal which is being&nbsp;emitted).
This completely optional filtering mechanism is mainly used as an
optimization for signals which are often emitted for many different reasons:
the clients can filter out which events they are interested in before the
closure’s marshalling code runs. For example, this is used extensively by
the notify signal of GObject: whenever a property is modified on a GObject,
instead of just emitting the notify signal, GObject associates as a detail
to this signal emission the name of the property modified. This allows
clients who wish to be notified of changes to only one property to filter
most events before receiving&nbsp;them.
As a simple rule, users can and should set the detail parameter to zero:
this will disable completely this optional filtering for that&nbsp;signal.
Content
-----
